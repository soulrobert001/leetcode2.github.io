
## 题目描述

给定一个数组 `nums`，要求将数组中的所有 `0` 移动到数组的末尾，同时保持数组中非零元素的相对顺序不变。

### 题目要求

- 你必须 **原地** 修改给定的数组，不能使用额外的数组或数据结构。
- 需要尽量减少操作的时间复杂度。


## 解题思路

我们可以通过双指针的方法来解决这个问题。

### 方法一：双指针法

1. **思路**：
   - 我们可以用两个指针来遍历数组：
     - **`lastNonZeroFoundAt`**：记录下一个非零元素应该放置的位置。
     - **`current`**：用来遍历整个数组。
   - 每当我们遇到非零元素时，就将它放到 `lastNonZeroFoundAt` 位置，然后更新 `lastNonZeroFoundAt`。
   - 最后，所有剩下的元素（即为 `0`）会自动被移动到数组的末尾。

2. **步骤**：
   - 用一个 `current` 指针从头到尾遍历数组。
   - 如果 `nums[current]` 是非零元素，就将其放到 `nums[lastNonZeroFoundAt]` 位置，并递增 `lastNonZeroFoundAt`。
   - 遍历完成后，`lastNonZeroFoundAt` 之后的元素都应该是 `0`。

3. **时间复杂度**：
   - 遍历数组一次，时间复杂度为 `O(n)`，其中 `n` 是数组的长度。

4. **空间复杂度**：
   - 由于是原地操作，因此空间复杂度为 `O(1)`。

## 代码实现

```c
#include <stdio.h>

void moveZeroes(int* nums, int numsSize) {
    int lastNonZeroFoundAt = 0;  // 记录下一个非零元素应该放的位置

    // 遍历数组
    for (int current = 0; current < numsSize; current++) {
        // 如果当前元素是非零的
        if (nums[current] != 0) {
            // 将非零元素移动到 lastNonZeroFoundAt 位置
            nums[lastNonZeroFoundAt] = nums[current];
            // 如果 current 和 lastNonZeroFoundAt 不同，则将当前位置赋为 0
            if (current != lastNonZeroFoundAt) {
                nums[current] = 0;
            }
            lastNonZeroFoundAt++;  // 更新下一个非零元素的位置
        }
    }
}

int main() {
    int nums[] = {0, 1, 0, 3, 12};
    int numsSize = sizeof(nums) / sizeof(nums[0]);

    moveZeroes(nums, numsSize);

    // 打印结果
    for (int i = 0; i < numsSize; i++) {
        printf("%d ", nums[i]);
    }
    printf("\n");

    return 0;
}

##总结
##该问题的关键是通过双指针来有效地移动零元素到数组的末尾，同时保持非零元素的顺序不变。
##这种方法的时间复杂度为 O(n)，并且空间复杂度为 O(1)，符合题目要求的原地操作。
